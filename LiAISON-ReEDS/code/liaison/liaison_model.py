import sys
from numpy import random
import numpy as np
import secrets
import pandas as pd
import uuid
import pickle
import yaml
import os
import time
from liaison.montecarloforeground import mc_foreground
from liaison.lci_calculator import brightway,lcia_traci_run,lcia_recipe_run, lcia_premise_gwp_run
from liaison.lci_modifier import brightway_modifier



def correct_natural_land_transformation(bw):
    lt = [m for m in bw.methods if "natural land transformation" in m[1]]
 
    white_list = [
        "forest",
        "gassland, natural",
        "sea",
        "ocean",
        "inland waterbody",
        "lake, natural",
        "river, natural",
        "seabed, natural",
        "shrub land",
        "snow",
        "unspecified",
        "wetland",
        "bare area",
    ]
     
    l_flows = []
    for l in lt:
        m = bw.Method(l)
        cfs = m.load()
        cfs = [cf for cf in cfs if any(n in bw.get_activity(cf[0])["name"] for n in white_list)]
        m.write(cfs)


def correct_bigcc_copper_use(bw,db):
    list_dbs = [
    db
    ]

    list_acts = [
    "electricity production, at BIGCC power plant, no CCS",
    "electricity production, at BIGCC power plant, pre, pipeline 200km, storage 1000m",
    "electricity production, at BIGCC power plant, pre, pipeline 400km, storage 3000m",
    ]

    for db in list_dbs:
        for ds in bw.Database(db):
            if ds["name"] in list_acts:
                    for exc in ds.exchanges():
                        if exc["name"] == "Construction, BIGCC power plant 450MW":
                            #print("found exchange to correct")
                            exc["amount"] = 1.01e-11
                            exc.save()


def reset_project(updated_project_name,number,project,updated_database,bw):
    
    """
    This function copies the project directory of a certain year and scenario, for example
    ecoinvent RCP 19 2030 and creates a copy of the project using a non repeatable name
    using 


    Parameters
    ----------
    db: str
        database name for scenario and year
    
    number : str
        random number generated by uuid to create no duplicate databases
    
    project : str 
        generic project name
        
    bw : module
        brightway2 module loaded shortcut name
        

    
    Returns
    -------
    project name : str
        Name of the project
    """

    project_name = project+updated_project_name+number
    try:
      print('Trying to delete project',project_name)
      bw.projects.delete_project(project_name,delete_dir = True)
      print('Project deleted',flush=True)
    except:
      print('Project does not exist',flush=True)
      pass
    bw.projects.set_current(updated_project_name)
    print("Entered project " + updated_project_name,flush = True)
    print("Databases in this project are",flush = True)
    print(bw.databases,flush = True)
    try:
        bw.projects.copy_project(project_name,switch = False)
        print('Project copied successfully',flush=True)
    except:
        bw.projects.purge_deleted_directories()
        bw.projects.copy_project(project_name,switch = False)
        print('Project copied successfully after directory deleted',flush=True)    

    bw.projects.set_current(project_name)
    print("Current new project " + project_name,flush = True)
    print("Databases in this project are",flush = True)    
    print(project_name,flush = True)
    print(bw.databases,flush = True)
    print('Correcting Natural Land Transformation Recipe method', flush = True)
    correct_natural_land_transformation(bw)
    print('Correcting BIG CC copper use',flush = True)
    correct_bigcc_copper_use(bw,updated_database)
    return project_name

def main_run(lca_project,updated_project_name,initial_year,results_filename,mc_foreground_flag,lca_flag,lca_activity_modification,regional_sensitivity_flag,region,data_dir,primary_process,process_under_study,location_under_study,updated_database,mc_runs,inventory_filename,modification_inventory_filename,process_name_bridge,emission_name_bridge,location_name_bridge,output_dir,bw):

    """
    This function defines the result arrays and then calls monte carlo analysis if required or just runs the 
    LCIA run once for analysis. 


    Parameters
    ----------
    project: str
        project name as provided by user        
    
    results_filename : str
        filename for the result         
    
    mc_foreground_flag : boolean 
        boolean for monte carlo simulation to operate

    lca_flag : boolean 
        boolean for Life cycle analysis to operate
        
    primary_process : str
       the process under LCA study  

    location_under_study : str
        location of the process under stidy

    updated_database : str
       database name for scenario and year
        
    mc_runs : int
       number of monte carlo runs       
        
    inventory_filename : str
        filename for the process foreground inventory  

    modification_inventory_filename: str
        filename for the process inventory that will be modified inside ecoinvent      
    
    process_name_bridge : str
        filename for the link between common process names and ecoinvent process names    
    
    emission_name_bridge : str
        filename for the link between common emission names and ecoinvent emission names
    
    location_name_bridge : str
       filename for the link between common location names and ecoinvent location names
    
    output_dir : str
       output directory for saving results       
    
    bw: module
       brightway2 module

    Returns
    -------
    None
    """
    

    
    
    print('\n')
    print(updated_database,flush=True)
    print("Staring LCA runs", flush=True)
    print('\n')
    'remove all uncertainty from the background with this command'
    #remove_background_uncertainty(db) 
    yr = updated_database[10:14]
    scenario = updated_database[15:]
    number = str(secrets.token_hex(8))

    def lca_runner(db,r,mc_runs,mc_foreground_flag,lca_flag):


            lcia_result = {}
            lcia_df = pd.DataFrame()
            lcia = []
            value = []
            unit = []
            year = []
            method = []
        
            """
            This function defines the result arrays and then calls monte carlo analysis if required or just runs the 
            LCIA run once for analysis. 
    
    
            Parameters
            ----------
            db : 
                ecoinvent database name under study with scenario and year        
            
            r : str
                blank for normal runs or numerical for monte carlo simulation number          
    
            Returns
            -------
            None
            """
  
            project_name = reset_project(updated_project_name,number,lca_project,updated_database,bw)
            if lca_activity_modification:
               print('Activity modified already previously! Not doing again!!',flush=True)

            dictionary = brightway(db,run_filename,mc_foreground_flag,mc_runs,process_name_bridge,emission_name_bridge,location_name_bridge,bw)                   
            print('Activity created and saved success',flush=True)
            if lca_flag: 
                result_dir1,n_lcias1 = lcia_traci_run(db,dictionary[process_under_study+'@'+location_under_study],1,mc_foreground_flag,mc_runs,bw)
                result_dir2,n_lcias2 = lcia_recipe_run(db,dictionary[process_under_study+'@'+location_under_study],1,mc_foreground_flag,mc_runs,bw)
                #result_dir3,n_lcias3 = lcia_premise_gwp_run(db,dictionary[process_under_study],1,mc_foreground_flag,mc_runs,bw)
                result_dir3 = {}
                n_lcias3 = 0
                temp1= pd.DataFrame.from_dict(result_dir1,orient='index')
                temp2= pd.DataFrame.from_dict(result_dir2,orient='index')
                temp3= pd.DataFrame.from_dict(result_dir3,orient='index')
                
                for count in range(0,n_lcias1):
                        #not implemented
                        monteC = False
                        if monteC:#not implemented
            
                                mc_runs = temp1['result'][0][count][1]
                                for mc in mc_runs:
                                        lcia.append(temp1['result'][0][count][0])
                                        value.append(mc)
                                        unit.append(temp1['result'][0][count][2])
                                        year.append(db)
                                        method.append('TRACI2.1')
                        
                        else:
            
                                lcia.append(temp1['result'][0][count][0])
                                value.append(temp1['result'][0][count][1])
                                unit.append(temp1['result'][0][count][2])
                                year.append(db)
                                method.append('TRACI2.1')
            
            
            
            
                for count in range(0,n_lcias2):
            
            
                        #not implemented
                        monteC = False
                        if monteC:#not implemented
            
                            mc_runs = temp2['result'][0][count][1]
                            for mc in mc_runs:
                                    lcia.append(temp2['result'][0][count][0])
                                    value.append(mc)
                                    unit.append(temp2['result'][0][count][2])
                                    year.append(db)
                                    method.append('RECIPE')   
            
                        else:
            
                            lcia.append(temp2['result'][0][count][0])
                            value.append(temp2['result'][0][count][1])
                            unit.append(temp2['result'][0][count][2])
                            year.append(db)
                            method.append('RECIPE')
                              
                for count in range(0,n_lcias3):
            
            
                        #not implemented
                        monteC = False
                        if monteC:#not implemented
            
                            mc_runs = temp3['result'][0][count][1]
                            for mc in mc_runs:
                                    lcia.append(temp3['result'][0][count][0])
                                    value.append(mc)
                                    unit.append(temp3['result'][0][count][2])
                                    year.append(db)
                                    method.append('IPCC 2013')   
            
                        else:
            
                            lcia.append(temp3['result'][0][count][0])
                            value.append(temp3['result'][0][count][1])
                            unit.append(temp3['result'][0][count][2])
                            year.append(db)
                            method.append('IPCC 2013')

                                  
                
                lcia_df = pd.DataFrame(
                    {'lcia': lcia,
                     'value': value,
                     'unit': unit,
                     'year': year,
                     'method': method     
                    })    
                
                lcia_df.to_csv(output_dir+results_filename+str(r)+db+primary_process+'.csv',index = False)

                save_project = False
                if save_project == True:
                
                        time0 = time.time()
                        try:
                                import bw2io
                                bw2io.backup.backup_project_directory(project_name)
                                print(bw2io.backup.backup_project_directory(project_name))
                                print('saved successfully', flush = True)
                                print('Time taken for saving project'+str(time.time() - time0))


                        except:
                                print('failed to backup project')

                return lcia_df
       
      
    if mc_foreground_flag:
         
        lca_runner(updated_database,r,mc_runs,mc_foreground_flag,lca_flag)
    

    elif regional_sensitivity_flag:

        file = pd.read_csv(inventory_filename)
        file['process_location'] = region
        file['supplying_location'] = region
        print('Regional Sensitivity analysis starts')
        run_filename = os.path.join(data_dir,'sensitivity_regional'+updated_database+str(yr)+'.csv')
        file.to_csv(run_filename,index = False)  
        r = ''    
        lca_runner(updated_database,r,mc_runs,mc_foreground_flag,lca_flag)

    else:
        
        run_filename = inventory_filename
        r = ''
        lca_runner(updated_database,r,mc_runs,mc_foreground_flag,lca_flag)
            
    try:
        bw.projects.delete_project(bw.projects.current, delete_dir=True) 
        print('Deleted succesfully')
        bw.projects.purge_deleted_directories()
    except:
        print('There was an issue with deletion')
        bw.projects.purge_deleted_directories()

